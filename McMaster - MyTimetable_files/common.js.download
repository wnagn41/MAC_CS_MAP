function refreshOnUserStateChange(){
	var activeUserId = getCookie("vsbActiveUserId");
	if (!activeUserId) return; // cookies broken
	var activeAdviseeId = getCookie("vsbActiveAdviseeId");
	if(!adviseeId || adviseeId == null) {
		adviseeId = "";
	}
	// check if userId or adviseeId has changed
	if( !(userId.indexOf("GUEST_")==0 && activeUserId.indexOf("GUEST_")==0) && ( (userId!=activeUserId)||(adviseeId!=activeAdviseeId) )) {
		var html=i8n.activeUserConflict;
		if (activeUserId.indexOf("GUEST_")==0) {
			html=i8n.activeUserLogout;
		}
		if (typeof popupNotice !== 'undefined' && popupNotice != null) {
			var buttons=[{name:"Refresh",action:function() {popupNotice.close();location.reload();}}];
			RR.popNotice(html,buttons);
		} else {
			if ($(".toast-error").length==0) {
				toastr.error('<button type="button" class="btn btn-toastr" onclick="toastr.clear(); location.reload()" style="color:black">Refresh</button>' , html, {timeOut:0,extendedTimeOut:0});
			}
		}
	}
}

setInterval(refreshOnUserStateChange, 5000);	

var visLocations=new Array();
var oldAccess=null;
var NONE_TEXT="None";
var lastPiaCookies=null;

function $e(id) {
    return document.getElementById(id);
}

if (!String.prototype.trim) {
  String.prototype.trim = function () {
    return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
  };
}

function selectAll(el) {
    el.focus();
    el.select();
}

function countProperties(obj) {
    var c = 0;
    for(var prop in obj) {
        c++;
    }
    return c;
}

function selCheck(req,course,csi,selected) {
	$e("csi"+req+"_"+course+"_"+csi).checked=selected;
	var curr=$e("sa_"+req+"_"+course).value;
	// remove parity char
	curr = curr.substring(0,curr.length-1);
	var i=csi*1;

	// Depends on SelectionInfo and DataMassage
	var code = curr.charCodeAt(i);
	code-=65;
	if (selected) {
		code=code|32;
	}
	else {
		code=code&223;
	}
	code+=65;
	var v=String.fromCharCode(code);

	var newCurr=curr.substring(0,i)+v+curr.substring(i+1);
	newCurr=addParity(newCurr);
	$e("sa_"+req+"_"+course).value=newCurr;
}

function addParity(str) {
	var v=0;
	for (var i=0;i<str.length;i++) {
		v+=str.charCodeAt(i);
	}
	v = "a".charCodeAt(0) + v%26;
	var c = String.fromCharCode(v);
	return str+c;
}


function loadxmlToDiv(xmlurl,destDiv) {

	var xmlhttp;
	if (window.XMLHttpRequest) {
		// code for IE7+, Firefox, Chrome, Opera, Safari
		xmlhttp=new XMLHttpRequest();
	} else {
		// code for IE6, IE5
		xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
	}

	xmlhttp.onreadystatechange=function() {
		if (xmlhttp.readyState==4 && xmlhttp.status==200) {
			document.getElementById(destDiv).innerHTML=xmlhttp.responseText;
	    }
	};
	xmlhttp.open("GET",xmlurl,true);
	xmlhttp.send();
}


function locToName(loc) {
	for(var i=0;i<mslocs.length;i++) {
		var ms=mslocs[i];
		if (ms.value==loc) {
			return ms.text;
		}
	}
	var pts=loc.split("i");
	if (pts.length>=2 && pts[0]!="SHARE") {
		return locToName("SHAREi"+pts[1]);
	}
	return loc;
}

// TODO remove
function updateAccess(skipProcess) {
	if (BB.access==oldAccess) {
		return;
	}
	oldAccess=BB.access;
	if (BB.access) {

		tabbing=true;

		if (!disableHotkeys) {
			$(".accessible").each(function() {
				var c=$(this).attr("class");
				// Convert all ak_ classes into accesskey attributes.
				var i1=c.indexOf("ak_");
				if (i1>0) {
					var ak=c.substr(i1+3,1);
					$(this).attr("accesskey",ak);
				}
			});
		}

		var e = document.createElement('link');
	    e.href = document.location.protocol + 'css/accessibility.css?v=37';
	    e.type = 'text/css';
	    e.rel = 'stylesheet';
	    e.media = 'screen';
	    e.id = 'access_link';
	    document.getElementsByTagName('head')[0].appendChild(e);

	} else {
		$("#access_link").remove();

	}
	if (BB.access) {
		$(".timesToAvoid").show();
	} else {
		$(".timesToAvoid").hide();
	}

	//var $wi=$("#wheelchair_icon");
	//$wi.attr("src","images/"+(BB.access?"regular":"access")+".png");
	$("#access_link_text").html((BB.access?i8n.decreaseAccessibility:i8n.increaseAccessibility));
	$("#access_link_text_top").html((BB.access?i8n.decreaseAccessibility:i8n.increaseAccessibility));

	if (BB.access) {
		$(".term_region").detach().prependTo("#term_region_alt");
		$("#term_region_alt").show();
	} else {
		$(".term_region").detach().prependTo("#term_region_pri");
		$("#term_region_alt").hide();
	}

	if (!(skipProcess)) {
		BB.activeState.outdated=true;
		BB.activeState.process();
	}

}

function setCookie(cname, cvalue, exdays) {
    var d = new Date();
    d.setTime(d.getTime() + (exdays*24*60*60*1000));
    var expires = "expires="+d.toUTCString();
    document.cookie = cname + "=" + cvalue + "; " + expires;
}

function getCookie(cname) {
    var name = cname + "=";
    var ca = document.cookie.split(';');
    for(var i=0; i<ca.length; i++) {
        var c = ca[i];
        while (c.charAt(0)==' ') c = c.substring(1);
        if (c.indexOf(name) == 0) return c.substring(name.length,c.length);
    }
    return "";
}

function getCookies(ending) {
	var c={};
	$.each(document.cookie.split(/; */), function()  {
		var splitCookie=this.split('=');
		var n=splitCookie[0];
		if (ending && !n.endsWith(ending)) return;
  		c[n]=splitCookie[1];
	});
	return c;
}

// clientActivity - time of last user action on page
// serverActivity - time of last server request.

// logoutTime - if not zero, VSB will logout if all page activity older than this in milliseconds and user is authenticated. (Guest sessions will last forever)
// keepAlive - if not zero, will send server request after this many milliseconds since last sessionActivity if user is still active
// maxDataAge - if not zero, if user active, will check for Selection seat availability updates every X milliseconds
// forceAlive - if true, will not care if there is page activity or not.
// checkLogout - if true, periodically check if user logged out of SSO
function VsbTimer(logoutTime,keepAlive,maxDataAge,forceAlive,checkLogout) {

	var serverActivity=0;
	var clientActivity=0;
	var lastDataRefresh=(new Date()).getTime();
	var lastSisActivity=(new Date()).getTime()-(9*60*1000);
	var lastDay = null;
	
	var lastPsList=getCookie("PS_LOGINLIST");

	this.didServerActivity = function() {
		serverActivity = (new Date()).getTime();
	}
	this.didServerActivity();

	this.didCientActivity = function() {
		clientActivity = (new Date()).getTime();
	}
	this.didCientActivity();

	var me=this;

	$(document).on("mousemove", function(e) {
		me.didCientActivity();
	});
	$(document).on("keydown", function(e) {
		me.didCientActivity();
	});

	var logoutTime=logoutTime;
	var keepAlive=keepAlive;
	var forceAlive=forceAlive;

	this.doLogin = function() {
		if (typeof custDoLogin == "function") {
			custDoLogin();
		} else {
			window.location.href='login.jsp';
		}
	}

	this.doLogout = function(cause) {
		var getout = function() {
			if (typeof custDoLogout == "function") {
				custDoLogout(cause);
			} else {
				var url="login.jsp?logout="+cause;
				if (isAuthenticatedWithSso) {
					url+="&was_ps_sso=1";
					if (lastPsList.length>0) {
						url+="&url="+encodeURIComponent(baseUri+"EMPLOYEE/"+altHRMS+"/?cmd=logout");	
					}
				}
				document.location.href=url;
			}
		}
		if (typeof Profiler !== 'undefined' && typeof Profiler.exists !== 'undefined') {
			Profiler.reportToServer(getout);
		} else {
			getout();
		}
	}

	var logoutChecker = function() {
		if (disablePsLogoutCheck) {
			return;	
		}
		var newPsList=getCookie("PS_LOGINLIST");
		if (isAuthenticatedWithSso && (getCookie("PS_TOKENEXPIRE")=="-1" || lastPsList.length>0 && newPsList=="")) {
			delete Profiler; // Prevent report-usage from triggering logout early
			me.doLogout("SSO_LOGOUT");
		}
		// Note: this wont normally work because these cookies are normally Secure
		var cs=getCookies("-PORTAL-PSJSESSIONID");
		var change=false;
		if (lastPiaCookies!=null) {
			for (var c in cs) {
				if (!lastPiaCookies[c] || lastPiaCookies[c]!=cs[c]) {
					change=true;
					break;
				}
			}
		}
		lastPiaCookies=cs;
		if (change) {
			location.reload(); // Refresh page in case auth changed
		}
	}

	var keepSessionAlive = function () {
		me.didServerActivity();
		$.ajax({
			  url: "realtime.jsp",
			  cache: false
			})
			  .done(function( html ) {
			    // nothing
			  });
	}

	var activityChecker = function() {

		if (checkLogout) {
			logoutChecker();
		}

		if (serverActivity==0) return;

		var now=(new Date()).getTime();

		//console.log("VsbTimer. ServerAge:"+(now-serverActivity)+" ClientAge:"+(now-clientActivity)+" SeatAge:"+(now-lastDataRefresh)+" KeepAliveMax:"+keepAlive+" LogoutMax:"+logoutTime+" maxDataAge:"+maxDataAge);
		//popup warning user that session will expire in 2 mins
		if(logoutTime!=0 && now>(clientActivity+logoutTime-120000) && isAuthenticated){
			let buttons=[{name:"OK",action:function() {popupNotice.close();}}];
			let msg = "Your session will expire soon."; 
			RR.popNotice(msg,buttons);
		}
		
		if (logoutTime!=0 && now>(clientActivity+logoutTime) && isAuthenticated) {
			me.doLogout("no_activity");
		}

		if ((forceAlive || (clientActivity+20000>now)) &&
			now>(serverActivity+keepAlive)) {
			keepSessionAlive();
		}

		if ((clientActivity+20000>now)) {
			if (now>lastSisActivity+600000) {
				// 10 min have past since SIS keep-alive
				lastSisActivity=now;
				// If we are using PS, prevent the timeout of the PIA session.
				if (getCookie("PS_TOKENEXPIRE").length>2 && isAuthenticatedWithSso) {
					var now=(new Date()).getTime();
					// CORS compatible:
					(function(){
					    (new Image()).src = baseUri+"EMPLOYEE/"+altHRMS+"/?cmd=resettimeout&t="+now;
					})();
				}
				// If we are using something else
				if (typeof custKeepAlive == "function") {
					var u = custKeepAlive();
					var now=(new Date()).getTime();
					$.get(u+"&t="+now)
					.done(function() {
						// refreshed SIS
					})
					.fail(function() {
						console.log("SIS refresh failed");
					});

				}
			}
		}

		if (typeof BB !== 'undefined') {
			// Ensure we're using VSB
			if (maxDataAge>0 && (clientActivity+20000>now) && now>(lastDataRefresh+maxDataAge)) {
				lastDataRefresh=now;
				if (BB.enrollMode) {
					// Don't try to update seat availability if
					// user if doing checkout
					return;
				}
				// Refresh live seat availability
				BB.activeState.process(false,true);
			}
		}

		var dayNow = (new Date()).getDay();
		if (lastDay!=null && dayNow!=lastDay) {
			EE.newDay();
		}
		lastDay = dayNow;

	}

	setInterval(function() {
		activityChecker();
	},2000);

}
var vsbTimer=null;


function sendUrlParamToField(param,field,massager) {
    var sPageURL = window.location.search.substring(1);
    var vars=sPageURL.split('&');
    for (var i=0;i<vars.length;i++) {
        var vn=vars[i].split('=');
        if (vn[0]==param) {
        	var d=vn[1];
        	if (massager) {
        		d=massager(d);
        	}
        	$(field).val(d);
        }
    }
}


function getUrlParam(sParam) {
    var sPageURL = window.location.search.substring(1);
    return getUrlParameter(sParam,sPageURL);
}

function nWindow() {
	var f8b0=["\x26\x74\x3D","\x26\x65\x3D"]
	var t=(Math.floor((new Date())/60000))%1000;
	var e=t%3+t%39+t%42;
	return f8b0[0]+t+f8b0[1]+e;
}

function getUrlParameter(sParam,url) {
    var vars=url.split('&');
    for (var i=0;i<vars.length;i++) {
        var vn=vars[i].split('=');
        if (vn[0]==sParam) {
            return vn[1];
        }
    }
    return "";
}

function convertTermsToParams(terms) {
	s="&term=";
	for (var i=0;i<terms.length;i++) {
		if (i>0) s+=",";
		s+=terms[i];
	}
	return s;
}

function clearSearch(saveTerm) {
	if (typeof BB !== 'undefined') {
		window.location.href="criteria.jsp?src=clear"+(BB.access?"&access=1":"")+(saveTerm?"&term="+BB.activeState.term:"")+(BB.lang!="en"?"&lang="+BB.lang:"");
	} else {
		window.location.href="criteria.jsp?src=clear";
	}
}

function clickPrint() {
	// Temporarily ensure results is
	// the active page for printing
	var $pc=$("#page_criteria");
	var $pf=$("#page_favorites");
	var $pr=$("#page_results");

	var ap="active_vsb_page";

	var c=$pc.hasClass(ap);
	var f=$pf.hasClass(ap);
	var r=$pr.hasClass(ap);

	$pc.removeClass(ap);
	$pf.removeClass(ap);
	$pr.addClass(ap);

	window.print();

	$pc.toggleClass(ap,c);
	$pf.toggleClass(ap,f);
	$pr.toggleClass(ap,r);
}

function lookupAcadCareer(ac) {
	if (ac=="UGRD") return "Undergraduate";
	if (ac=="GRAD") return "Graduate";
	return ac;
}

var cctr=0;
function consolelog(str) {
	var c=$("#console");
	c.show();
	var h=c.html();
	h+="<br/>"+(cctr++)+":"+str;
	c.html(h);
}

function isMobile() {
	return ($("body").width() < 680);
}

function sameContents(a1,a2) {
	var c=0;
	for (var p in a1) {
		if (a1.hasOwnProperty(p)) {
			c++;
			if (p in a2) {
				// good
			} else {
				return false;
			}
		}
	}
	var d=0;
	for (var p in a2) {
		if (a2.hasOwnProperty(p)) {
			d++;
		}
	}
	if (c!=d) return false;
	return true;
}

function getPosition(e){
	var left = 0;
	var top  = 0;

	while (e.offsetParent){
		left += e.offsetLeft;
		top  += e.offsetTop;
		e     = e.offsetParent;
	}

	left += e.offsetLeft;
	top  += e.offsetTop;

	return {x:left, y:top};
}

function getCampusDesc(campus) {
	for (var i=0;i<mscams.length;i++) {
		if (mscams[i].value==campus) {
			return mscams[i].text;
		}
	}
	// Not in visible cams:
	var orig=MM.campuses[campus];
	if (orig!=="undefined") return orig;
	// Not anywhere
	return campus;
}

function getInstructionalMethodDesc(im) {
	for (msi of msinstructForTerm) {
		if (msi.value==im) {
			return {text:msi.text,title:msi.title};
		}
	}
	return null;
}

function getLocations(locs) {
	var s="";
	for (var l in locs) {
		var desc=locToName(l);
		if (s.length>0) s+=", ";
		s+=desc;
	}
	return s;
}

function getSessions(sessions) {
	var s="";
	for (var ses in sessions) {
		var desc=sessionToName(ses);
		if (s.length>0) s+=", ";
		s+=desc;
	}
	return s;
}

function sessionToName(ses) {
	for(var i=0;i<mssessionForTerm.length;i++) {
		var session=mssessionForTerm[i];
		if (session.value==ses) {
			return session.text;
		}
	}
	return ses;
}

function getDateFromJsDate(date) {
	  var day = date.getDate();
	  var monthIndex = date.getMonth();
	  var year = date.getFullYear();
	  return getMonth(monthIndex) + " " + day + ", " + year;
}

function getDateTimeFromJsDate(date) {
	  var day = date.getDate();
	  var monthIndex = date.getMonth();
	  var year = date.getFullYear();
	  return getMonth(monthIndex) + " " + day + " " + year + " " + date.getHours() + ":" + date.getMinutes();
}

function sortDayHours(dayHourA,dayHourB) {
	var firstHour;
	var lastHour;
	var firstDay;
	var lastDay;
	if (dayHourA.hour<dayHourB.hour) {
		firstHour=dayHourA.hour;
		lastHour=dayHourB.hour;
	} else {
		firstHour=dayHourB.hour;
		lastHour=dayHourA.hour;
	}
	if (dayHourA.day<dayHourB.day) {
		firstDay=dayHourA.day;
		lastDay=dayHourB.day;
	} else {
		firstDay=dayHourB.day;
		lastDay=dayHourA.day;
	}
	// Ensure it is within range
	if (firstDay<schedule.firstDay) firstDay=schedule.firstDay;
	if (lastDay>schedule.lastDay) lastDay=schedule.lastDay;
	if (firstHour<schedule.firstHour) firstHour=schedule.firstHour;
	if (lastHour>schedule.lastHour-(blockTimeInterval/60)) lastHour=schedule.lastHour-(blockTimeInterval/60);
	return {first:{day:firstDay,hour:firstHour},last:{day:lastDay,hour:lastHour}};
}

function cleanCnKey(cnKey) {
	if (cnKey.charAt(cnKey.length-1)=="-") return cnKey.substr(0,cnKey.length-1);
	return cnKey;
}

// A debouce function prevents something from running too often.
var debounce = function (func, threshold, execAsap) {
    var timeout;
    return function debounced () {
        var obj = this, args = arguments;
        function delayed () {
            if (!execAsap)
                func.apply(obj, args);
            timeout = null;
        };
        if (timeout)
            clearTimeout(timeout);
        else if (execAsap)
            func.apply(obj, args);
        timeout = setTimeout(delayed, threshold || 100);
    };
}

function extAttrToDisplay(key) {
	switch (key) {
	case "GFCH":
		return "GFC Hours";
	case "rProg":
		return "Restricted Program";
	case "rMajor":
		return "Restricted Major";
	case "rColl":
		return "Restricted College";
	case "rCamp":
		return "Restricted Campus";
	case "rDep":
		return "Restricted Department";
	case "rCls":
		return "Restricted Class";
	case "rLevl":
		return "Restricted Level";
	case "rDegc":
		return "Restricted Degree";
	case "rAtts":
		return "Restricted Attribute";
	case "rChrt":
		return "Restricted Cohort";
	case "cNotes":
		return "Notes";
	}
	return null;
}

function getTimeDisplayString (classes, examFormat, ds, isAddLoc) {
	var texts1={};
	var texts2={};
	var locText={};
	for (var b=0;b<classes.length;b++) {
		var cls=classes[b];
		var locations=cls.loos;
		for (var tbi=0;tbi<cls.timeblocks.length;tbi++) {
			var tb=cls.timeblocks[tbi];
			var loc=locations[tb.id];
			var a=tb.t1+'_'+tb.t2+(isAddLoc?'_'+loc:'');
			texts1[a]=texts1[a]||[];
			texts1[a].push(tb);
			locText[a]=loc;
		}
	}

	for(var it in texts1){
		var bloks = texts1[it];
		var loc = locText[it];
		for(var c=0;c<bloks.length;c++){
			var bk = bloks[c];
			var a=it+'_'+bk.d1+'_'+bk.d2;
			texts2[a] = texts2[a]||[];
			var dur=bk.duration();
			if (ds != null) {
				if (ds==dur) dur=""; // don't show dates redundantly if they're the same
			} else {
				dur="";
			}
			var ac;
			if (!(typeof BB === "undefined")) {
				ac=BB.access;
			} else {
				ac=true;
			}
			if(isAddLoc){
				texts2[a].push([bk,bk.weekDay(ac),dur,bk.toTimeFormatted(),loc]);
			} else{
				texts2[a].push([bk,bk.weekDay(ac),dur,bk.toTimeFormatted()]);
			}
		}
	}
	var texts4 = [];

	if(examFormat) {
		var exams=0;
		var examTxt=i8n.exam+": ";
		for(var it in texts2){
			var bloks = texts2[it];
			var sti = [];
			var have = {};
			for(var k=0;k<bloks.length;k++){
				var bk = bloks[k];
				var day = bk[1];
				if (have[day]) continue;
				have[day]=true;
				sti.push(day);
			}

			var builtstring = "";
			if(bloks[0][0].xm){
				exams++;
				builtstring = examTxt;
			}
			
			builtstring += sti.join(", ")+" "+bloks[0][2]+": "+bloks[0][3]+(isAddLoc?" <span class='legend_multi_loc'>"+bloks[0][4]+"</span>":"");
			texts4.push([builtstring,bloks[0][0].d1]);
		}
	}
	else {
		for(var it in texts2){
			var bloks = texts2[it];
			var sti = [];
			var have = {};
			for(var k=0;k<bloks.length;k++){
				var bk = bloks[k];
				var day = bk[1];
				if (have[day]) continue;
				have[day]=true;
				sti.push(day);
			}

			var builtstring = "";
			builtstring += sti.join(", ")+" "+bloks[0][2]+": "+bloks[0][3]+(isAddLoc?" <span class='legend_multi_loc'>"+bloks[0][4]+"</span>":"");
			texts4.push([builtstring,bloks[0][0].d1]);
		}
	}

	texts4.sort(function(a, b){return a[1]-b[1];});
	var timesDisp="";
	for (var ti=0;ti<texts4.length;ti++) {
		var t=texts4[ti][0];
		if (exams>1) {
			t=t.replace(examTxt,"");
		}
		timesDisp+=t+"<br/>";
	}
	if (typeof i8n !== 'undefined' && timesDisp.length>0 && i8n.timezoneToShow) {
		timesDisp+=" "+i8n.timezoneToShow;
	}
	return timesDisp;
}

function writeObjectIntoSelect($select,obj,addBlank,sortByVal) {
	var oldVal=$select.val();
	var h="";
	if (addBlank) {
		h+="<option value=''></option>";
	}
	var keysSorted=[];
	if (sortByVal) {
		keysSorted=Object.keys(obj).sort(function(a,b){
			return obj[a].localeCompare(obj[b]);
		});
	} else {
		for (var key in obj) {
			keysSorted.push(key);
		}
	}
	for (var i=0;i<keysSorted.length;i++) {
		var key=keysSorted[i];
		var val=obj[key];
		h+="<option value='"+key+"'>"+val+"</option>";
	}
	$select.html(h);
	$select.val(oldVal);
	return keysSorted.length;
}

function sortSetByValue(set) {
	var keysSorted=Object.keys(list).sort(function(a,b){return list[a]-list[b]})
	var newSet={};
	//for ()
}

function parseWildcard(reqId) {
	if (!reqId) return null;
	// Same as ClassData.getCodeNumbersWithWildcard
	var wcs2=[];
	var wcs=reqId.split("||");

	function hasAny(arr) {
		for (var i=0;i<arr.length;i++) {
			if (arr[i]=="@") return true;
		}
		return false;
	}

	for (var i=0;i<wcs.length;i++) {
		var wc=wcs[i];
		wc=wc.trim().replace(/-/g," ");
		var is=wc.split(/\s+/);
		if (is.length<2) continue;
		var codes=is[0].split("|");
		var nums=is[1].split("|");
		var attrs=is.length>=3?is[2].split("|"):"@";
		if (hasAny(codes)) codes=null;
		if (hasAny(nums)) nums=null;
		if (hasAny(attrs)) attrs=null;
		var wc2={codes:codes,nums:nums,attrs:attrs};
		wcs2.push(wc2);
	}
	return wcs2;
}

function wildcardsToDesc(wcs,term) {
	if (wcs.length==1) {
		var wc=wcs[0];
		if (wc.codes==null && wc.nums==null && wc.attrs && wc.attrs.length==1) {
			var attr=wc.attrs[0];
			if (MM.termBundle[term]) {
				var rdDesc=MM.termBundle[term].requirementdesignations[attr];
				if (rdDesc) {
					return {title:rdDesc}; // Requirement Designation
				}
				var ca=MM.termBundle[term].courseattributes[attr];
				if (ca) {
					return {title:i8n.core+": "+ca.description};
				}
			}
			if(!MM.cores[attr]){
				return {title:i8n.core+": "+attr};
			}else {
				return {title:i8n.core+": "+MM.cores[attr]};
			}
		}
		if (wc.attrs==null && wc.codes && wc.codes.length==1 && wc.nums && wc.nums.length==1) {
			return {title:wc.codes[0]+" "+wc.nums[0]};
		}
		return {codesD:wc.codes,numsD:wc.nums,attrsD:wc.attrs};
	}
	return null;
}

function setMdlCheck($el,checked) {
	$el.prop("checked",checked).parent().toggleClass("is-checked",checked);
}

function initSdlInput($el) {
	$el.focusin(function(ev) {
		$(this).parents(".sdl_input").addClass("is-focused");
	});
	$el.focusout(function(ev) {
		$(this).parents(".sdl_input").removeClass("is-focused");
	});
	$el.change(function(ev) {
		$(this).parents(".sdl_input").toggleClass("is-length",$(this).val().length>0);
	})
}

// MDL items in the template were obfuscated to prevent them
// from being upgraded by MDL. De-obfuscate them.
function deObfuscateMdl($el) {
	$el.find("*").each(function() {
		var cl=$(this)[0].className;
		if (cl.indexOf("Dmdl-")>=0) {
			$(this)[0].className=cl.replace(new RegExp("Dmdl-",'g'),"mdl-");
		}
	});
}

function deObfuscateId($el) {
	$el.find(".dynID").each(function() {
		var id=$(this).prop("id");
		if (id) {
			id=id.replace(new RegExp("dyn-",'g'),"");
			$(this).prop("id",id);
		}
		var fori=$(this).attr("for");
		if (fori) {
			fori=fori.replace(new RegExp("dyn-",'g'),"");
			$(this).attr("for",fori);
		}
	});
}

function dateFromISO8601(isoDateString) {
	var parts = isoDateString.match(/\d+/g);
	var isoTime = Date.UTC(parts[0], parts[1] - 1, parts[2], parts[3], parts[4], parts[5]);
	var isoDate = new Date(isoTime);
	return isoDate;
}

// Filter wildcard options by campus
function filterOptions(options,gcams,cnKey) {
	if (!options) return [];
	// Determine global institutions
	var ginsts={};
	for (gc in gcams) {
		var g2=gc.indexOf("i") > -1 ?gc.split("i")[0]:"";
		ginsts[g2]=true;
	}

	var voptions=[];
	for (var i=0;i<options.length;i++) {
		var op=options[i];
		var hasInst=false;
		var fTitles=[]; // Dynamic title(s) for selected insts.
		for (ginst in ginsts) {
			if (typeof op.instAndTitle[ginst] !== "undefined") {
				hasInst=true;
				fTitles.push(op.instAndTitle[ginst]);
			}
		}
		if (cnKey==op.cnKey || hasInst) {
			op.fTitles=fTitles.join(" / ");
			voptions.push(op);
		}
	}
	return voptions;
}


function preload(arrayOfImages) {
	$(".preload_image").remove();
    $(arrayOfImages).each(function () {
        $('<img class="preload_image"/>').attr('src',this).appendTo('body').css('display','none');
    });
}

function lenientEquals(a,b) {
	// Allow for one to be null
	// and the other ""
	if (!a && !b) return true;
	return a==b;
}

function deepEquals(x,y) {
	if (x===y) return true;
	if (!(x instanceof Object) || !(y instanceof Object)) return false;
	if (x.constructor !== y.constructor) return false;
	for (var p in x) {
		if (! x.hasOwnProperty(p)) continue;
		if (! y.hasOwnProperty(p)) return false;
		if (x[p] === y[p]) continue;
		if (typeof( x[p] ) !== "object") return false;
		if (!deepEquals(x[p],y[p])) return false; // recursive
	}
	for ( p in y ) {
		if ( y.hasOwnProperty( p ) && ! x.hasOwnProperty( p ) ) {
			return false;
		}
	}
	return true;
}


function prepAttributes(attrs) {
	function prepAttribute(att,vals) {
		ca=MM.termBundle[BB.activeState.term].courseattributes[att];
		if (!ca) {
			// Don't recognize this
			return "";
		}

		// Sort vals if needed
		vals.sort(function(a,b) {
			var ta=legendAttrFirst.indexOf(a)>=0;
			var tb=legendAttrFirst.indexOf(b)>=0;
			if (ta==tb) {
				return a-b;
			}
			if (ta) return -1;
			return 1;
		});
		var disp="";
		for (var vi=0;vi<vals.length;vi++) {
			var val=vals[vi];
			if (disp.length>0) disp+=", ";
			var attrDisp="";
			var dd=ca.values[val];
			if (!dd) {
				// value not enabled for display.
				// Show attr description instead
				attrDisp=ca.description;
			} else {
				attrDisp=dd;
			}
			if (legendAttrValDisp) {
				attrDisp=val+" ["+attrDisp+"]";
			}
			if (legendAttrBold.indexOf(val)>=0) {
				attrDisp="<strong>"+attrDisp+"</strong>";
			}
			if (EE.stuGps && EE.stuGps.hasOwnProperty(att)) {
				attrDisp="<span class='highlighter'>"+attrDisp+"</span>";
			}
			disp+=attrDisp;
		}
		return disp;
	}

	var attrSet = new Set();
	for (var att in attrs) {
		var pa=prepAttribute(att,attrs[att]);
		if (pa.length>0) {
			attrSet.add(pa);
		}
	}
	return Array.from(attrSet).join("; ");
}

// Convert to to title & description
function prepExtAttribute(att,vals) {

	var tit=extAttrToDisplay(att);
	if (!tit) {
		// Don't recognize this
		return null;
	}

	var disp="";
	if (!vals) {
		disp=NONE_TEXT;
	} else {
		// Sort vals if needed
		vals.sort(function(a,b) {
			var ta=legendAttrFirst.indexOf(a)>=0;
			var tb=legendAttrFirst.indexOf(b)>=0;
			if (ta==tb) {
				return a-b;
			}
			if (ta) return -1;
			return 1;
		});

		for (var vi=0;vi<vals.length;vi++) {
			var val=vals[vi];
			if (disp.length>0) {
				disp+=", ";
			}
			disp+=val;

		}
	}
	
	var hoverTitle=prepRestrictionTitle(att,disp);
	return {title:tit,disp:disp,hoverTitle:hoverTitle};
}

function prepRestrictionTitle(att,desc) {
	if (att.indexOf("r")!=0) return "";
	var hoverTitle="";
	var hasIncl=false;
	var hasExcl=false;
	if (desc.indexOf("(Include)")>=0) hasIncl=true;
	if (desc.indexOf("(Exclude)")>=0) hasExcl=true;
	if (hasIncl&&hasExcl) {
		hoverTitle="You must belong to one or more of the 'Include' items and not belong to the 'Exclude' items";
	} else if (hasIncl) {
		hoverTitle="You must belong to one or more of the 'Include' items";
	} else if (hasExcl) {
		hoverTitle="You must not belong to the 'Exclude' items";
	}
	return hoverTitle;
}


// Utility used to collect multiple text descriptions of which
// many might be identical, then determine the distinguishing
// properties of the descriptions, and describe them to a user.
function CombinedDescription() {

	var descs={};
	var allProps={};
	var noneOnly=true;
	var variations=0;
	var adds=0;
	var expectedAdds=0; // If the number of adds is less than the expected, make sure to show "None" for other things.
	var justSayOther=0.7;

	// Add a String, with properties, such as {inst:"a",acadCareer:"UGRD"}
	this.addDescription = function(desc,props) {
		adds++;
		desc=desc.trim().replace(/\s\s+/g, ' '); // Get rid of extra tabs, spaces, newlines to help merging
		if (desc.length==0) desc=NONE_TEXT;
		if (desc!=NONE_TEXT) {
			noneOnly=false;
		}
		var d=descs[desc];
		if (d==null) {
			d={};
			descs[desc]=d;
		}
		for (var prop in props) {
			allProps[prop]=true;
			var p=d[prop];
			if (p==null) {
				p={};
				d[prop]=p;
			}
			var v=props[prop];
			p[v]=true;
		}
	}

	this.setExpectedAdds = function(ea) {
		expectedAdds=ea;
	}

	this.getDescriptions = function() {
		var goodProps={};
		// Find out which property(s) have no overlap across all the different descriptions
		for (var prop in allProps) {
			var overlap=false;
			dance:
			for (desc1 in descs) {
				var p1=descs[desc1][prop];
				for (desc2 in descs) {
					if (desc1==desc2) continue;
					var p2=descs[desc2][prop];
					// Check for overlap
					for (v1 in p1) {
						if (p2.hasOwnProperty(v1)) {
							overlap=true;
							break dance;
						}
					}
				}
			}
			if (!overlap) {
				goodProps[prop]=true;
			}
		}

		// If more than 1 good one, find out which one is least verbose
		var winner=null;
		var leastValues=9999999;
		nextprop:
		for (var prop in goodProps) {
			var c=0;
			for (desc1 in descs) {
				var p1=descs[desc1][prop];
				for (var v1 in p1) {
					if (v1=="") break nextprop;
					c++;
				}
			}
			if (c<leastValues) {
				winner=prop;
				leastValues=c;
			}
			goodProps[prop]=c;
		}

		// Create combined description
		var ds=[];
		for (desc in descs) {
			var d={};
			var names=[];
			if (winner) {
				var p=descs[desc][winner];
				for (var v in p) {
					names.push(v);
				}
			}
			d.names=names;
			d.desc=desc;
			d.distinguishing=winner;
			ds.push(d);
		}
		return ds;
	}

	function translateName(prop,val) {
		switch (prop) {
		case "inst":
			return MM.collegeToDescr(val);
		case "ac":
			return lookupAcadCareer(val);
		default:
			return val;
		}
	}

	// For example, use ("{}: ","{}"," / ",", ",false,"Others") for the most common format
	this.describeIt = function(nameFormat,descFormat,joiner,nameJoiner,translate,otherText,blankIfNone) {
		if (blankIfNone && noneOnly) return "";
		var ds=this.getDescriptions();
		if (!otherText) otherText="Others";
		if (adds<expectedAdds && !noneOnly) {
			ds.push({names:[otherText],desc:NONE_TEXT}); // TODO: ensure otherLabel by itself, ensure translate doesn't cause crash. Percent threshold for others
		}
		var vs=[]; // variations
		for (var i=0;i<ds.length;i++) {
			var di=ds[i];
			var d="";

			// Names part
			var cnames=[];
			for (var j=0;j<di.names.length;j++) {
				var name=di.names[j];
				if (translate) {
					name=translateName(di.distinguishing,name);
				}
				cnames.push(name);
			}
			cnames.sort();
			var cname=cnames.join(nameJoiner);
			if (adds==expectedAdds && di.names.length>expectedAdds*justSayOther) {
				cname="<span title='"+cname.replace(/'/g,'\\')+"'>"+otherText+"</span>";
			}

			if (ds.length>1 && nameFormat) {
				d+=nameFormat.replace("{}",cname);
			}

			// Description part
			var desc2=di.desc.trim();
			var j2=joiner.trim();

			// Strip joiner if already present in description
			if (desc2.substr(desc2.length-j2.length)==j2) {
				desc2=desc2.substr(0,desc2.length-j2.length);
			}
			var title=prepRestrictionTitle("r",desc2);
			descFormat=descFormat.replace("[]",title);
			d+=descFormat.replace("{}",desc2);

			vs.push(d);
		}
		variations=i;
		vs.sort();

		return vs.join(joiner);
	}

	this.isNone = function() {
		return noneOnly;
	}

	this.nbVariations = function() {
		return variations;
	}

	this.test1 = function() {
		var a=new CombinedDescription();
		a.addDescription("Sad",{store:"pet",class:"C",ac:"UGRD"});
		a.addDescription("Happy",{store:"pet",class:"C",ac:"GRAD"});
		console.log(a.describeIt("{}: ","{}"," / ",", ",true,"Others"));

		var a=new CombinedDescription();
		a.addDescription("",{store:"pet",class:"C",ac:"UGRD"});
		a.addDescription("Full",{store:"pet",class:"C",ac:"GRAD"});
		console.log(a.describeIt("{}: ","{}"," / ",", ",true,"Others"));

		var a=new CombinedDescription();
		a.addDescription("",{store:"pet",class:"C",ac:"UGRD"});
		a.setExpectedAdds(3);
		console.log(a.describeIt("{}: ","{}"," / ",", ",true,"Others"));
	}
}

function replaceUrlParam(url, paramName, paramValue) {
    if (paramValue==null) {
        paramValue='';
    }
    var pattern=new RegExp('\\b('+paramName+'=).*?(&|#|$)');
    if (url.search(pattern)>=0) {
        return url.replace(pattern,'$1'+paramValue+'$2');
    }
    url=url.replace(/[?#]$/,'');
    return url + (url.indexOf('?')>0?'&':'?')+paramName+'='+paramValue;
}

function openNewTab(url){
   window.open(url, '_blank').focus();
}

function evalCourseRg(rgLines,allCids,allStrms) {
	var isMetFct = function(rgl,allCids,allStrms) { // uses cids
		// Ensure coreq
		if (rgl.type!="CRSE"||rgl.rtype!="CO") return 2;
		// Check that co-req is met
		if (rgl.cid.length>0) {
			// PS Type. Needs strm matchup also.
			if (rgl.strm=="" || !allStrms[+rgl.strm]) return 2;
			if (!allCids[(+rgl.cid)]) return 0;
			return 1;
		}
		if (rgl.cnKey.length>0) {
			if (!allCids[rgl.cnKey]) return 0;
			return 1;
		}
		return 2;
	}
	return evalRgLines(rgLines,isMetFct,allCids,allStrms);
}

function sisTerms() {
	var ts=EE.studentDetail.terms.filter(t => (t.visibleSchoolTermIds.find(v => v==BB.activeState.term)));
	var psTerms=[];
	for (var t of ts) {
		psTerms.push(t.term.institution+"-"+t.term.acadCareer+"-"+t.term.schoolTermId);
	}
	return psTerms;
}

function schoolTermIdsFromVisibleTerm(term) {
	var schoolTermIds=[];
	if(EE.studentDetail && EE.studentDetail.terms) {
		var terms=EE.studentDetail.terms.filter(t => (t.visibleSchoolTermIds.find(v => v==term)));
		for (var t of terms) {
			var sti=t.term.schoolTermId;
			if (!schoolTermIds.find(s => s==sti)) {
				schoolTermIds.push(sti);
			}
		}
	}
	return schoolTermIds;
}

function hasEnrolledCourse(){
	var cnfs=BB.activeState.cnfs;
	for (var i=0;i<cnfs.length;i++) {
		var cnf=cnfs[i];
		if (cnf.enr && !coursesToIgnoreForHasEnrolled.includes(cnf.cnKey)) {
			return true; 
		}
	}
	return false;
}

// Fix for iPhone w/ Safari 14
(function($){
	$.fn.data2=function(key,val) {
		var o={};
		var c=$(this).attr("data2");
		if (c) {
			c=decodeURIComponent(c);
			o=JSON.parse(c);
		}
		if (!key) return o;
		if (typeof val === 'undefined') return o[key];
		o[key]=val;
		c=JSON.stringify(o);
		c=encodeURIComponent(c);
		$(this).attr("data2",c);
		return this;
	}; 
})(jQuery);

// Evaluate the Requirement Group lines
// 0=not met
// 1=met
// 2=unknown
function evalRgLines(rgLines,isMetFct,data1,data2) {
	if (rgLines.length<=0) return null;
	var culprit=null;
	var unknown=false;
	if (rgLines[0].connand) {
		var ifNoMoreAndThanSat=false;
		var nextMustBeOr=false;
		for (var rgl of rgLines) {
			if (ifNoMoreAndThanSat) {
				if (!rgl.lineand) continue;
				ifNoMoreAndThanSat=false;
			}
			if (nextMustBeOr) {
				if (rgl.lineand) {
					if (unknown) return 2;
					return 0;					
				}
				nextMustBeOr=false;
			}
			var r=isMetFct(rgl,data1,data2);
			if (r==1) {
				ifNoMoreAndThanSat=true;
			} else {
				culprit=rgl;
				nextMustBeOr=true;
				if (r==2) unknown=true;
			}
		}
		if (ifNoMoreAndThanSat) return 1;
		if (unknown) return 2;
		return 0;
	} else {
		// A or B or C -> (A' and B' and C')'
		var ifNoMoreAndThanSat=false;
		var nextMustBeOr=false;
		for (var rgl of rgLines) {
			if (ifNoMoreAndThanSat) {
				if (rgl.lineand) continue;
				ifNoMoreAndThanSat=false;
			}
			if (nextMustBeOr) {
				if (!rgl.lineand) {
					if (unknown) return 2;
					return 1;
				}
				nextMustBeOr=false;
			}
			var r=isMetFct(rgl,data1,data2);
			if (r==0) {
				ifNoMoreAndThanSat=true;
			} else {
				culprit=rgl;
				nextMustBeOr=true;
				if (r==2) unknown=true;
			}
		}
		if (ifNoMoreAndThanSat) return 0;
		if (unknown) return 2;
		return 1;
	}
}

function testEvalRgLines() {
	var data1=[];
	var data2=[];
	var isMetFct = function(rgl,data1,data2) {
		return rgl.val;
	}
	
	var rgLines;
	
	// ANDs
	
	// T and T and T
	rgLines=[{connand:true,val:1},{lineand:true,val:1},{lineand:true,val:1}];
	assert(evalRgLines(rgLines,isMetFct,data1,data2)==1);
	
	// U and T and T
	rgLines=[{connand:true,val:2},{lineand:true,val:1},{lineand:true,val:1}];
	assert(evalRgLines(rgLines,isMetFct,data1,data2)==2);
	
	// T and T and U
	rgLines=[{connand:true,val:1},{lineand:true,val:1},{lineand:true,val:2}];
	assert(evalRgLines(rgLines,isMetFct,data1,data2)==2);
	
	// T and T and F
	rgLines=[{connand:true,val:1},{lineand:true,val:1},{lineand:true,val:0}];
	assert(evalRgLines(rgLines,isMetFct,data1,data2)==0);
	
	// (T or T) and T
	rgLines=[{connand:true,val:1},{lineand:false,val:1},{lineand:true,val:1}];
	assert(evalRgLines(rgLines,isMetFct,data1,data2)==1);

	// (U or T) and T
	rgLines=[{connand:true,val:2},{lineand:false,val:1},{lineand:true,val:1}];
	assert(evalRgLines(rgLines,isMetFct,data1,data2)==1);

	// (U or T) and U
	rgLines=[{connand:true,val:2},{lineand:false,val:1},{lineand:true,val:2}];
	assert(evalRgLines(rgLines,isMetFct,data1,data2)==2);

	// (T or U) and T
	rgLines=[{connand:true,val:1},{lineand:false,val:2},{lineand:true,val:1}];
	assert(evalRgLines(rgLines,isMetFct,data1,data2)==1);

	// (F or T) and T
	rgLines=[{connand:true,val:0},{lineand:false,val:1},{lineand:true,val:1}];
	assert(evalRgLines(rgLines,isMetFct,data1,data2)==1);

	// (F or F) and T
	rgLines=[{connand:true,val:0},{lineand:false,val:0},{lineand:true,val:1}];
	assert(evalRgLines(rgLines,isMetFct,data1,data2)==0);
	
	// (F or T) and F
	rgLines=[{connand:true,val:0},{lineand:false,val:1},{lineand:true,val:0}];
	assert(evalRgLines(rgLines,isMetFct,data1,data2)==0);

	// (F or T) and (T or F)
	rgLines=[{connand:true,val:0},{lineand:false,val:1},{lineand:true,val:1},{lineand:false,val:0}];
	assert(evalRgLines(rgLines,isMetFct,data1,data2)==1);

	// (F or T) and (U or F)
	rgLines=[{connand:true,val:0},{lineand:false,val:1},{lineand:true,val:2},{lineand:false,val:0}];
	assert(evalRgLines(rgLines,isMetFct,data1,data2)==2);

	// (F or T) and (U or T)
	rgLines=[{connand:true,val:0},{lineand:false,val:1},{lineand:true,val:2},{lineand:false,val:1}];
	assert(evalRgLines(rgLines,isMetFct,data1,data2)==1);

	// (F or T) and (F or T)
	rgLines=[{connand:true,val:0},{lineand:false,val:1},{lineand:true,val:0},{lineand:false,val:1}];
	assert(evalRgLines(rgLines,isMetFct,data1,data2)==1);

	// (F or T or F)
	rgLines=[{connand:true,val:0},{lineand:false,val:1},{lineand:false,val:0}];
	assert(evalRgLines(rgLines,isMetFct,data1,data2)==1);

	// (T or T or U)
	rgLines=[{connand:true,val:1},{lineand:false,val:1},{lineand:false,val:0}];
	assert(evalRgLines(rgLines,isMetFct,data1,data2)==1);

	// (F or F or U)
	rgLines=[{connand:true,val:0},{lineand:false,val:0},{lineand:false,val:2}];
	assert(evalRgLines(rgLines,isMetFct,data1,data2)==2);

	
	// ORs
	
	// T or T or T
	rgLines=[{connand:false,val:1},{lineand:false,val:1},{lineand:false,val:1}];
	assert(evalRgLines(rgLines,isMetFct,data1,data2)==1);
	
	// T or T or U
	rgLines=[{connand:false,val:1},{lineand:false,val:1},{lineand:false,val:2}];
	assert(evalRgLines(rgLines,isMetFct,data1,data2)==1);
	
	// F or F or U
	rgLines=[{connand:false,val:0},{lineand:false,val:0},{lineand:false,val:2}];
	assert(evalRgLines(rgLines,isMetFct,data1,data2)==2);
	
	// T or F or F
	rgLines=[{connand:false,val:1},{lineand:false,val:0},{lineand:false,val:0}];
	assert(evalRgLines(rgLines,isMetFct,data1,data2)==1);
	
	// (F and F) or T
	rgLines=[{connand:false,val:0},{lineand:true,val:0},{lineand:false,val:1}];
	assert(evalRgLines(rgLines,isMetFct,data1,data2)==1);

	// (F and U) or T
	rgLines=[{connand:false,val:0},{lineand:true,val:2},{lineand:false,val:1}];
	assert(evalRgLines(rgLines,isMetFct,data1,data2)==1);

	// (T and F) or F
	rgLines=[{connand:false,val:1},{lineand:true,val:0},{lineand:false,val:0}];
	assert(evalRgLines(rgLines,isMetFct,data1,data2)==0);

	// (T and F) or T
	rgLines=[{connand:false,val:1},{lineand:true,val:0},{lineand:false,val:1}];
	assert(evalRgLines(rgLines,isMetFct,data1,data2)==1);
	
	// (F and F) or (T and T)
	rgLines=[{connand:false,val:0},{lineand:true,val:0},{lineand:false,val:1},{lineand:true,val:1}];
	assert(evalRgLines(rgLines,isMetFct,data1,data2)==1);

	// (F and U) or (T and T)
	rgLines=[{connand:false,val:0},{lineand:true,val:2},{lineand:false,val:1},{lineand:true,val:1}];
	assert(evalRgLines(rgLines,isMetFct,data1,data2)==1);

	// (F and F and F)
	rgLines=[{connand:false,val:0},{lineand:true,val:0},{lineand:true,val:0}];
	assert(evalRgLines(rgLines,isMetFct,data1,data2)==0);

	// (F and F and U)
	rgLines=[{connand:false,val:0},{lineand:true,val:0},{lineand:true,val:2}];
	assert(evalRgLines(rgLines,isMetFct,data1,data2)==0);

	// (T and T)
	rgLines=[{connand:false,val:1},{lineand:true,val:1}];
	assert(evalRgLines(rgLines,isMetFct,data1,data2)==1);
}

function assert(test) {
	if (!test) {
		console.error("Test failed");
		debugger;
	}
}

function padForNext(str) {
	if (str.substr(str.length-1)!=".") str+=".";
	str+=" ";
	return str;
}